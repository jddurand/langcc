cmake_minimum_required(VERSION 3.13.4) # 3.13.4 comes from https://llvm.org/docs/CMake.html#embedding-llvm-in-your-project
project(langcc VERSION 1.0.0 LANGUAGES CXX)
set (PROJECT_SUMMARY "A Next-Generation Compiler Compiler")

# Eventual custom cmake modules
list(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake)

#
# Redirect binary output to a dedicated folder
#
set (BINARY_OUTPUT_PATH "output/bin")
set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${BINARY_OUTPUT_PATH})
set (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${BINARY_OUTPUT_PATH})
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${BINARY_OUTPUT_PATH})
foreach (_config ${CMAKE_CONFIGURATION_TYPES})
  string (TOUPPER ${_config} _config )
  set (CMAKE_LIBRARY_OUTPUT_DIRECTORY_${_config} "${BINARY_OUTPUT_PATH}")
  set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${_config} "${BINARY_OUTPUT_PATH}")
  set (CMAKE_RUNTIME_OUTPUT_DIRECTORY_${_config} "${BINARY_OUTPUT_PATH}")
endforeach ()
#
# Revisit rpath if needed when doing installation
set (CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
set (CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

#
# OS flags
#
if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
  set(MACOSX TRUE)
else ()
  set(MACOSX FALSE)
endif ()

#
# Find dependencies
#
find_package(LLVM REQUIRED CONFIG)
message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")
if (NOT MACOSX)
  find_package(Unwind REQUIRED)
endif ()


#
# Add LLVM definitions
separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})
add_definitions(${LLVM_DEFINITIONS_LIST})

#
# Set include directories
#
include_directories(src gen ${LLVM_INCLUDE_DIRS})

#
# Create datacc target
#
add_executable(datacc
  src/datacc.cpp
  gen/cc__gen.cpp
  gen/data__gen.cpp
  src/datacc_main.cpp
)

#
# Files generated by datacc
#
add_custom_command(
    OUTPUT gen/common__data_gen.cpp
    COMMAND datacc src/common.data gen
)

#
# Create langcc target
#
add_executable(langcc
  src/langcc.cpp
  src/langcc_lexer.cpp
  src/langcc_parser_flatten.cpp
  src/langcc_parser_attr.cpp
  src/langcc_parser_cps.cpp
  src/langcc_parser_lr.cpp
  src/langcc_encode.cpp
  src/langcc_normalize.cpp
  src/langcc_emit.cpp
  gen/cc__gen.cpp
  gen/data__gen.cpp
  gen/meta__gen.cpp
  gen/common__data_gen.cpp
  src/datacc.cpp
  src/langcc_main.cpp
)

#
# Installation rules
#
include (GNUInstallDirs) # Use GNUInstallDirs in order to enforce lib64 if needed
include (InstallRequiredSystemLibraries) # Include system libraries if needed (like on Windows)
install (FILES src/langcc_util.hpp src/langcc_rt.hpp DESTINATION include COMPONENT HeaderComponent)
install (TARGETS datacc langcc RUNTIME DESTINATION bin COMPONENT ApplicationComponent)

#
# Packaging - this will create a "pack" target in the makefile if you do not want to use cpack
#
set (CPACK_PACKAGE_NAME                "${PROJECT_NAME}")
set (CPACK_PACKAGE_VENDOR              "${VENDOR}")
set (CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PROJECT_SUMMARY}")
set (CPACK_PACKAGE_VERSION             "${${PROJECT_NAME}_VERSION}")
set (CPACK_PACKAGE_VERSION_MAJOR       "${${PROJECT_NAME}_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR       "${${PROJECT_NAME}_VERSION_MINOR}")
set (CPACK_PACKAGE_VERSION_PATCH       "${${PROJECT_NAME}_VERSION_PATCH}")
#
# Get all components in one package
#
set (CPACK_COMPONENTS_GROUPING ALL_COMPONENTS_IN_ONE)
#
# Always enable archive
#
set (CPACK_ARCHIVE_COMPONENT_INSTALL ON)
#
# We want to recuperate some cmake variables to do a temporary install
# and the only way with via the CPackProperties.cmake file.
# This file must contain only CPack compatible commands -;
#
# Any variable starting with CPACK_ is exported to cpack...
#
set (CPACK_PROJECT_SOURCE_DIR ${PROJECT_SOURCE_DIR})
set (CPACK_PROJECT_CONFIG_FILE "${PROJECT_SOURCE_DIR}/CPackCustomProjectConfig.cmake")
set (CPACK_CMAKE_MAKE_PROGRAM ${CMAKE_MAKE_PROGRAM})
set (CPACK_TEMP_BASENAME "CpackTempDestdir")
set (CPACK_TEMP_DIRNAME ${PROJECT_SOURCE_DIR})
set (CPACK_TEMP_FULLPATH "${CPACK_TEMP_DIRNAME}/${CPACK_TEMP_BASENAME}")
#
# Generate CPACK_PROJECT_CONFIG_FILE
#
file (REMOVE ${CPACK_PROJECT_CONFIG_FILE})
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "MESSAGE (STATUS \"Removing \${CPACK_TEMP_FULLPATH}\")\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "file (REMOVE_RECURSE \${CPACK_TEMP_FULLPATH})\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "MESSAGE (STATUS \"Installing to \${CPACK_TEMP_FULLPATH}\")\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "EXECUTE_PROCESS (COMMAND \${CPACK_CMAKE_MAKE_PROGRAM} install DESTDIR=\${CPACK_TEMP_BASENAME} WORKING_DIRECTORY \${CPACK_TEMP_DIRNAME})\n")
#
# Rework internal variables to avoid zombies
#
GET_CMAKE_PROPERTY(COMPONENTS _components)
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "set (_component_ok_list)\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "FOREACH (_component IN LISTS CPACK_COMPONENTS_ALL)\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "  set (_install_manifest__path \"\${CPACK_PROJECT_SOURCE_DIR}/install_manifest_\${_component}.txt\")\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "  IF (EXISTS \${_install_manifest__path})\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "    FILE( READ \${_install_manifest__path} _content HEX)\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "    STRING (LENGTH \"\${_content}\" _content_length)\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "    IF (\${_content_length} GREATER 0)\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "      LIST (APPEND _component_ok_list \${_component})\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "    ENDIF ()\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "  ENDIF ()\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "ENDFOREACH ()\n")
file (APPEND ${CPACK_PROJECT_CONFIG_FILE} "set (CPACK_COMPONENTS_ALL \"\${_component_ok_list}\")\n")
#
# Include CPack - from now on we will have access to CPACK own macros
#
include (CPack)
#
# Install types
#
cpack_add_install_type (FullType        DISPLAY_NAME "Full")
cpack_add_install_type (DevelopmentType DISPLAY_NAME "Development")
#
# Groups
#
cpack_add_component_group (DevelopmentGroup  DISPLAY_NAME "Development" DESCRIPTION "Develoment files\n\nThis group contains libraries and headers"  EXPANDED)
#
# Components
#
cpack_add_component(HeaderComponent
  DISPLAY_NAME "Headers"
  DESCRIPTION "C/C++ Headers\n\nProgrammers will need these files"
  GROUP DevelopmentGroup
  INSTALL_TYPES FullType DevelopmentType)
cpack_add_component(ApplicationComponent
  DISPLAY_NAME "Applications"
  DESCRIPTION "Executables"
  GROUP RuntimeGroup
  INSTALL_TYPES FullType)

#
# Quite subtil, but the "package" target is not visible at this time. There is a old standing bug
# in CMake about this.
# We use a custom target for package generation.
# In addition man pages is generated using the INSTALL(CODE xxx) hack.
#
add_custom_target(pack
  COMMAND ${CMAKE_MAKE_PROGRAM} package
  COMMENT "Packaging ${PROJECT_NAME}"
  VERBATIM
)

#
# Tests
#
include(CTest)
add_executable (exe_unittest_lib EXCLUDE_FROM_ALL src/unittest_lib_main.cpp )
add_executable (exe_unittest_lang EXCLUDE_FROM_ALL src/unittest_lang_main.cpp )
add_test(NAME test_unittest_lib COMMAND $<TARGET_FILE:exe_unittest_lib>)

#
# Compile options
#
foreach (_project datacc langcc exe_unittest_lib exe_unittest_lang)
  #
  # C++ standard requirements
  #
  set_property(TARGET ${_project} PROPERTY CXX_STANDARD 17)
  #
  # Enable some C++ compiler flags when supported
  #
  target_compile_options(${_project} PRIVATE
    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
    -Wno-attributes>)
  #
  # Libraries
  #
  if (NOT MACOSX)
    target_link_libraries(${_project} PRIVATE Unwind::unwind)
  endif ()
endforeach ()

